let fmod_path = registry query 'Software\FMOD Studio API Windows' '' | get value
let repo_path = ^git rev-parse --show-toplevel | str trim

def fix [f: closure] {
    mut it = $in
    loop {
        let next = ($it | do $f)
        if $next == $it { break }
        $it = $next
    }
    $it
}

def translate [] {
    $in
    | str replace -a "\r\n" "\n"
    # translate #define
    | fix { str replace -ar 'typedef ([\w ]*) (\w+);\n(/\*.*?\*/\n)?#define (\w+) (\s*)(.*)\n' "${3}pub const $4: $5$2 = $6;\ntypedef $1 $2;\n" }
    | str replace -amr '^#define (\w+) (\s+)(\w+)$' "pub const $1: ${2}c_int = $3;"
    | str replace -amr '^#define (\w+) (\d+)$' "pub const $1: c_int = $2;"
    | str replace -amr '^#define (\w+) *(0x\w+)' "pub const $1: c_uint = $2;"
    # translate enum
    | str replace -ar 'typedef enum(.*)\n\{([^}]*?),? *\n\} (\w+)' "typedef enum $3\n{$2,\n} $3"
    | str replace -ar '\n\ntypedef enum (\w+)\n\{\n *(\w+), *' "\n\npub const $2: $1 = 0;\ntypedef enum $1\n{"
    | fix { str replace -ar 'typedef enum (\w+)\n\{\n *(\w+) *= ([-\w]+), *' "pub const $2: $1 = $3;\ntypedef enum $1\n{" }
    | fix { str replace -ar 'const (\w+)(.*)\ntypedef enum (\w+)\n\{\n(\n)? *(\w+), *' "const $1$2\n${4}pub const $5: $3 = $1 + 1;\ntypedef enum $3\n{" }
    # translate opaque typedefs
    | str replace -ar 'typedef struct +(\w+ *) .*;' "pub type $1 = self::_$1::$1; mod _$1 { #[repr(C)] pub struct $1 { _pin: ::core::marker::PhantomData<::core::marker::PhantomPinned>, _data: ::core::cell::UnsafeCell<[u8; 0]> } }"
    # translate fn items
    | str replace -ar '([\w*]+) +F_API ([\w (),*]*?)\);' "pub unsafe fn $2) -> $1;"
    # translate fn type aliases
    | str replace -ar 'typedef (\w+[ *]*) *\(F_CALL \*(\w+)\)( *)' "pub type $2$3 = unsafe extern "system" fn $1"
    # translate fn signatures
    | str replace -ar '(\w+[ *]*) \(([\w (),*.]*?)\);' "($2) -> $1;"
    | str replace -ar ' -> void *;' ";"
    | str replace -ar 'extern "system" fn \((.*) \.\.\.\)' 'extern "C" fn ($1 ...)'
    # make fn ptrs optional
    | str replace -ar '= (unsafe extern "system" fn.*?);' "= Option<$1>;"
    # translate type aliases
    | str replace -ar 'typedef enum.*\n\{\n+.*(= 65536.*\n)?\} (\w+);' "typedef int $2;"
    | str replace -ar '(?:typedef )?struct (\w+)\n\{([^}]*)\}.*;' "#[repr(C)] #[derive(Copy, Clone)] pub struct $1 {$2}"
    | str replace -ar 'typedef (\w[\w ]*\w) +(\w+);' "pub type $2 = $1;"
    # translate fields
    | str replace -amr '(?<=\(|, |^    )(\w[\w ]*?)\b *(\*[ \w*]*?)? *(\w+)(\[\w+\])?(?=[,);])' "$3: $1$2$4"
    | str replace -amr '^    (\w.*);$' "    pub $1,"
    | str replace -ar '(\d+): (\d+)\*' "$1 * $2"
    | str replace -ar 'Pty: Firelight Technologies' "Firelight Technologies Pty"
    # translate pointers
    | str replace -ar '(->|:) const (\w[\w ]*?)(\*+)' "$1 ${3}const $2"
    | str replace -ar '(->|:) (\w[\w ]*)(\*+)' "$1 ${3}mut $2"
    | str replace -ar '([\w*][ \w*]*) const\*,' "*const $1,"
    | str replace -ar '\*\*' "*mut *"
    # translate arrays
    | str replace -ar ': ([\w *]+)\[(.*?)\]' ": [$1; ($2) as usize]"
    # translate C primitive types
    | str replace -ar '\<int\>' "c_int"
    | str replace -ar '\<long long\>' "c_longlong"
    | str replace -ar '\<short\>' "c_short"
    | str replace -ar '\<char\>' "c_char"
    | str replace -ar '\<unsigned c_' "c_u"
    | str replace -ar '\<float\>' "c_float"
    | str replace -ar '\<void\>' "c_void"
    | str replace -ar '\<c_' "::core::ffi::c_"
    # escape reserved names
    | str replace -ar '\<type:' "r#type:"
    | str replace -ar '\<loop:' "r#loop:"
    # # translate includes
    # | str replace -ar '#include "(.*?)\.h"' 'include!("$1.rs");'
    # remove preprocessor directives
    | str replace -amr '^(\s*)#\w(.*\\\n)*.*\n' ""
    # translate extern block
    | str replace -ar 'extern "C" *\n' 'unsafe extern "system" '
    # mark as @generated
    | str replace -r '\A' "// @generated by carcinize.nu from FMOD headers\n"
}

def carcinize [lib, name, after?: closure] {
    let after = ($after | default {|| $in})
    let ch = $"api/($lib)/inc/($name).h"
    let rs = $"($repo_path)/crates/fmod-($lib)-sys/src/inc/($name).rs"
    print $"$FMOD_PATH/($ch) -> ($rs | path relative-to $env.PWD)"
    open $"($fmod_path)/($ch)" | translate | do $after | save -f $rs
}

def carcinize-core [] {
    carcinize "core" "fmod_codec" { $in
        | str replace -ar 'pub type FMOD_CODEC_(STATE|WAVEFORMAT).*?\n' ""
    }
    carcinize "core" "fmod_common" { $in
        | str replace -ar 'FMOD_BUILDNUMBER: ::core::ffi::c_int' "FMOD_BUILDNUMBER: ::core::ffi::c_uint"
        | str replace -ar 'pub type FMOD_ASYNCREADINFO.*?\n' ""
    }
    carcinize "core" "fmod_dsp_effects"
    carcinize "core" "fmod_dsp" { $in
        | str replace -ar 'pub type FMOD_(DSP_(STATE|BUFFER_ARRAY)|COMPLEX).*?\n' ""
        | str replace -mr '\n    union(.|\n)*?\}\n\} FMOD_DSP_PARAMETER_DESC;' '
    pub value: FMOD_DSP_PARAMETER_DESC_VALUE,
}

#[repr(C)] #[derive(Copy, Clone)] pub union FMOD_DSP_PARAMETER_DESC_VALUE {
    pub floatdesc: FMOD_DSP_PARAMETER_DESC_FLOAT,
    pub intdesc: FMOD_DSP_PARAMETER_DESC_INT,
    pub booldesc: FMOD_DSP_PARAMETER_DESC_BOOL,
    pub datadesc: FMOD_DSP_PARAMETER_DESC_DATA,
}'
    }
    carcinize "core" "fmod_errors" { $in
        # remove function fwd decl
        | str replace -amr '^.*__attribute__.*;$' ""
        # translate function signature
        | str replace -amr '^.*FMOD_ErrorString.*$' "#[inline] pub const unsafe extern "C" fn FMOD_ErrorString(errcode: FMOD_RESULT) -> *const std::ffi::c_char"
        # translate switch statement
        | str replace -ar 'switch ' "match "
        | str replace -ar 'case (\w+): ' "$1 =>"
        | str replace -ar 'default :' "_ => "
        # translate c strings
        | str replace -ar '(".*?");' "c$1.as_ptr(),"
    }
    carcinize "core" "fmod_output" { $in
        | str replace -ar 'pub type FMOD_OUTPUT_(STATE|OBJECT3DINFO).*?\n' ""
    }
    carcinize "core" "fmod"
}

def carcinize-studio [] {
    carcinize "studio" "fmod_studio_common" { $in
        | str replace -mr '\n\n    union(.|\n)*?\}\n\} FMOD_STUDIO_USER_PROPERTY;' '
    pub value: FMOD_STUDIO_USER_PROPERTY_VALUE,
}

#[repr(C)] #[derive(Copy, Clone)] pub union FMOD_STUDIO_USER_PROPERTY_VALUE {
    pub intvalue: ::core::ffi::c_int,
    pub boolvalue: FMOD_BOOL,
    pub floatvalue: ::core::ffi::c_int,
    pub stringvalue: *const ::core::ffi::c_char,
}'
    }
    carcinize "studio" "fmod_studio"
}

def main [] {
    carcinize-core
    carcinize-studio
}
